<h2>Lambda expressions</h2>
<div class="step-text">
<p>We already know how to declare functions with fixed names. Now, let's find out the last first-class-citizen feature: the opportunity to create a function at runtime and without a predefined name. That's lambda! Lambda is one of the most important features and is used profusely in modern programming.</p>
<h5 id="functions-without-names">Functions without names</h5>
<p>To create a Kotlin function that isn't bound to its name, you can use either an <strong>anonymous</strong> function or a <strong>lambda expression</strong>:</p>
<ul>
<li>
<p><code class="language-kotlin">fun(arguments): ReturnType { body }</code> – this is commonly called an "anonymous function".</p>
</li>
<li>
<p><code class="language-kotlin">{ arguments -&gt; body }</code> – this is commonly called a "lambda expression".</p>
</li>
</ul>
<p>To better understand it, take a look at the example below. Here, two functions are declared: they are declared in different ways, but they do the same thing:</p>
<pre><code class="language-kotlin">fun(a: Int, b: Int): Int {
    return a * b
} // normal function but no name 

{ a: Int, b: Int -&gt; a * b } // we shifted the paremater or argument in the curly braces</code></pre>
<p>As you see, they compute the multiplication of two numbers.</p>
<p>Both these functions have a reasonable type: <code class="language-kotlin">(Int, Int) -&gt; Int</code>. So, types work here just the way they do for top-level functions discussed in previous topics.</p>
<p>Note that if you want to declare a <strong>lambda without arguments</strong>, you do not need to write the "arrow symbols". A lambda without argument definition looks like this: <code class="language-kotlin">{ body }</code>.</p>
<p>You may ask: how can we use a function without a known name? The answer is: there are several options.</p>
<p>For example, you can assign the function to a variable and then invoke it by invoking the variable:</p>
<pre><code class="language-kotlin">val mul1 = fun(a: Int, b: Int): Int {
    return a * b
}

val mul2 = { a: Int, b: Int -&gt; a * b }

println(mul1(2, 3))  // prints "6"
println(mul2(2, 3))  // prints "6" too</code></pre>
<p>Also, you can pass such a function as an argument or return such a function from another function.</p>
<p>Finally, you can place parentheses with desired arguments right after the function definition to invoke it in place. However, that doesn't make much sense. So, mostly the first three described options are used.</p>
<p>The process of creating these two functions is quite similar, but lambdas have a more concise and convenient syntax. Therefore, lambdas are almost always used to create a function at runtime in real life. Moreover, there are programmers who don't stick to Kotlin official naming rules and can say "an anonymous function" instead of "a lambda". Despite the fact that everybody understands them, we suggest that you use the proper naming.</p>
<p>For the same reason of convenience, now we will talk only about lambdas.</p>
<h5 id="lambdas-and-syntactic-sugar">Lambdas and syntactic sugar</h5>
<p>There are ways to make code more readable for human beings without changing the code logic. If there is such a way in a programming language and it relates to syntax, we call it <strong>syntactic sugar</strong>. Kotlin promotes Functional Programming so there is syntactic sugar for it.</p>
<p>Let's recall this example of passing a function as an argument:</p>
<pre><code class="language-kotlin">fun isNotDot(c: Char): Boolean = c != '.'
val originalText = "I don't know... what to say..."
val textWithoutDots = originalText.filter(::isNotDot) 
println(textWithoutDots) // I don't know what to say</code></pre>
<p>Simply put, we have created the function <code class="language-kotlin">isNotDot</code>, which returns <code class="language-kotlin">Boolean</code> and then uses <code class="language-kotlin">originalText.filter</code>, which will iterate over every char in the string, apply the <code class="language-kotlin">isNotDot</code> function, and then return a string without any dots. The filter excludes any char in the string that returns false.</p>
<p>Just in case, there is a specific topic for <a href="https://hyperskill.org/learn/step/22367" rel="noopener noreferrer nofollow" target="_blank">filtering elements in collection</a>.</p>
<p>Now, let's rewrite it to pass a lambda:</p>
<pre><code class="language-kotlin">val originalText = "I don't know... what to say..."
val textWithoutDots = originalText.filter({ c: Char -&gt; c != '.' })
println(textWithoutDots) // I don't know what to say</code></pre>
<p>It works! First of all, we don't need to specify a function and then take reference from it.</p>
<p>Kotlin infers types of many objects, and here specifying the <code class="language-kotlin">c</code> type isn't necessary:</p>
<pre><code class="language-kotlin">originalText.filter({ c -&gt; c != '.' })</code></pre>
<p>Second, there are situations when the lambda is passed as the last argument. In such a case, Kotlin provides a way to eliminate bracket sequences ({ }) and write the lambda outside the parentheses:</p>
<pre><code class="language-kotlin">originalText.filter() { c -&gt; c != '.' }</code></pre>
<p>If the parentheses are left empty after that operation, you can remove them:</p>
<pre><code class="language-kotlin">originalText.filter { c -&gt; c != '.' }
</code></pre>
<p>Please note that sometimes function reference is more readable than a lambda, and there is no right answer which one is preferable. However, if the code is quite complex, instead of copy-pasting some lambda, it may be better to use function reference for easier maintenance and reusability.  </p>
<h5 id="implicit-name-of-a-single-parameter-it">Implicit name of a single parameter: it </h5>
<p>Finally, when there is a single parameter in a lambda, there is an opportunity to skip it. The parameter is available under the <code class="language-kotlin">it</code> name. The type of <code class="language-kotlin">it</code> is inferred from the type of the argument being passed to the lambda. The final version of the code that removes dots is this:</p>
<pre><code class="language-kotlin">val originalText = "I don't know... what to say..."
val textWithoutDots = originalText.filter { it != '.' }</code></pre>
<p>Pretty impressive, huh?</p>
<h5 id="conclusion">Conclusion</h5>
<p>Lambda expressions are one of the most important and powerful features in Kotlin and in functional programming. In this topic, we've learned what anonymous functions and lambdas are. Lambdas help us create functions at runtime. This is convenient when calling functions from Kotlin standard library (e.g., those processing data), as it helps reduce code length. Finally, we've hopefully convinced you that functions are first-class citizens in the Kotlin language.</p>
</div>
